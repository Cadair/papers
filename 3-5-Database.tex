\subsection{The SunPy Database}
% TODO: reference / footnote to Summer of Code website?
The database package has been added as a Google Summer of Code (GSoC) project
in 2013. Its purpose is to offer a database interface to store and manage data
that has been retrieved via packages from the net package. Note that currently
only the \textsc{VSO} package is supported, not the HEK package. It is also
possible to add entries by file or directory which is especially useful when
\textsc{FITS} files already exist on the user's local hard drive. This
facilitates the transition to using the database package for users who have
been using the \textsc{VSO} package isolated before.

The need for a database package arose because using \textsc{VSO} alone led to
two major problems:

\begin{enumerate}
  \item downloaded data cannot be queried or browsed
  \item to fetch data that has already been saved on the local hard drive,
    the VSO has to be queried again
\end{enumerate}

Because the Python library SQLAlchemy\footnote{\url{http://www.sqlalchemy.org}}
is used, many SQL dialects are supported. Using a file-based SQLite database
has the advantage of being easy to set up (the file will be created
automatically, so the user doesn't have to configure anything beforehand).
It is also handy to be passed around because all the database entries are just
in one single file. A server-based database, on the other hand, is the better
option for collaborative teams who work together from different machines on the
same data: a central database server stores all data and the clients connect to
it to read or write data.

Each database is a cache with a certain size limit (the size is determined by
the number of saved database entries). If no cache size is given, it is per
default $\infty$, which in practice means that caching is disabled then. There
are two builtin caching algorithm to choose from (LRU\footnote{Least Recently
Used}, LFU\footnote{Least Frequently Used}) but it's also possible to implement
a custom algorithm.

To solve the second problem that was mentioned above, the database saves all
queries which have been sent to the \textsc{VSO} to add new entries. If a query
has already been used once and the \texttt{fetch} method of the \texttt{Database}
class is called, the database is queried instead of the \textsc{VSO}. This
reduces bandwidth and is especially advantageous if there are big files behind
the query or if the query results in a big list of files.

A very special feature of the database package is the support to \texttt{undo}
and \texttt{redo} all writing operations. This is particularly convenient in
interactive sessions of the Python interpreter to revert accidental operations
easily. But looking ahead, this feature will also be desired when creating a
frontend for this package, for example a graphical user interface
(\textsc{GUI}).

Using the database package, one uses the \texttt{Database} class to connect
with a database and perform operations on it.

\begin{listing}[H]
\begin{minted}{python}
>>> from sunpy.net import vso
>>> from sunpy.database import Database
>>> database = Database('sqlite:///')
>>> database.download(
...     vso.attrs.Time((2011, 9, 20, 1), (2011, 9, 20, 2)),
...     vso.attrs.Instrument('RHESSI'))
>>> len(database)
6
\end{minted}
\caption{Connecting to a database and adding new entries.}
\label{code:db_1}
\end{listing}

In the code listing \ref{code:db_1}, a connection to new SQLite in-memory
database is established. After that, the attributes from the \textsc{VSO}
package are used to query the \textsc{VSO} and download the corresponding
files. The function \texttt{len} can be used to get the number of all database
records.

Note that the number of new database entries does not depend on the
number of files being downloaded but on the total number of \textsc{FITS}
headers in the files! If the used query had been used to query the \textsc{VSO}
directly, the number of query results would have been 2. You can see in the
following code example, listing \ref{code:db_2}, that indeed the entries can
be grouped to two results. The reason for six entries in the database is that
these RHESSI files have three headers each in this case, so the total number of
FITS headers is $2 \times 3 = 6$ headers.

The function \texttt{display\_entries} displays an iterable of database entries
in a nicely-formatted \textsc{ASCII} table. The headlines correspond to the
attributes of the respective database entries.

\begin{listing}[H]
\begin{minted}{python}
>>> from sunpy.database.tables import display_entries
>>> print display_entries(
...     database,
...     ['id', 'observation_time_start', 'wavemin', 'wavemax', 'download_time'])
id observation_time_start wavemin        wavemax           download_time      
-- ---------------------- -------        -------           -------------      
1  2011-09-20 01:09:20    0.413280643067 7.29318781883e-05 2014-01-18 19:21:35
2  2011-09-20 01:09:20    0.413280643067 7.29318781883e-05 2014-01-18 19:21:35
3  2011-09-20 01:09:20    0.413280643067 7.29318781883e-05 2014-01-18 19:21:35
4  2011-09-19 23:33:40    0.413280643067 7.29318781883e-05 2014-01-18 19:24:53
5  2011-09-19 23:33:40    0.413280643067 7.29318781883e-05 2014-01-18 19:24:53
6  2011-09-19 23:33:40    0.413280643067 7.29318781883e-05 2014-01-18 19:24:53
\end{minted}
\caption{Displaying database entries in a table.}
\label{code:db_2}
\end{listing}
